/*Курсовой проект по профессиональному модулю МДК 03.01 "Технология
разработки программного обеспечения"
по теме: "Разработка программы обращения квадратной матрицы
с помощью союзной"
Язык: С++
Среда: Visual Studio
Название: Обратная матрица
Разработал: Крапивкин Вячеслав Анатольевич

Краткое описание:
Данная програма находит обратную матрицу данной квадратной матрице.
Задание:
Разработать программу обращения квадратной матрицы с помощью союзой матрицы.
 -1     1       ~
А  =  -----  *  А,
       detA
Переменные, используемые в программе:
matr - исходная матрица;
n - размерность матрицы;
opred - определитель матрицы;
p - вспомогательная матрица для нахождения минора;
algdop - матрица алгебраических дополнений;
talgdop - транспонированная матрица алгебраических дополнений;
c - множитель -1 в степени i+j;
i - счётчик строк;
j - счётчик столбцов;
Подпрограммы, используемые в программе:
vvod - процедура ввода матрицы;
vivod - процедура вывода матрицы;
GetMatr - процедура для нахождения минора матрицы;
detmatr - функция для нахождения определителя матрицы;
alg - функция для нахождения алгебраического элемента матрицы.
*/
#include <iostream>
#include <iomanip>
using namespace std;

/*vvod - процедура ввода матрицы.
Формальные параметры:
matr - матрица;
n - размерность матрицы.
Локальные переменные:
i - счётчик строк;
j - счётчик столбцов.
*/
void vvod(double **matr, int n) {
	cout << "Введите элементы матрицы (в диапазоне от -100 до 100)" << endl;
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			cout << "matr[" << i + 1 << "][" << j + 1 << "]= ";
			cin >> matr[i][j];

			while ((matr[i][j] < -100) || (matr[i][j] > 100)) {
				cout << "Ошибка. Указано недопустимое значение." << endl;
				cout << "Повторите ввод: " << endl;
				cout << "matr[" << i + 1 << "][" << j + 1 << "]= ";
				cin >> matr[i][j];
			}
		}
	}
}

/*vivod - процедура вывода матрицы.
Формальные параметры:
matr - матрица;
n - размерность матрицы.
Локальные переменные:
i - счётчик строк;
j - счётчик столбцов.
*/
void vivod(double **matr, int n){
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			cout << setw(18) << matr[i][j];
		}
		cout << endl;
	}
}

/*GetMatr - процедура нахождения минора матрицы.
Формальные параметры:
matr - сходная матрица;
p - матрица для нахождения минора;
i - номер строки исходной матрицы;
j - номер столбца исходной матрицы;
m - размерность исходной матрицы.
Локальные переменные:
ki - счетчик строк матрицы для нахождения минора;
kj - счетчик столбцов матрицы для нахождения минора;
di - индекс строки исходной матрицы;
dj - индекс столбца исходной матрицы;
столбца элемента матрицы минора в исходной матрице.
*/
void GetMatr(double **matr, double **p, int i, int j, int m) {
	int ki, kj, di, dj;
	di = 0;
	for(ki = 0; ki < m - 1; ki++) { // Проверка индекса строки
		if (ki == i) di = 1;
		dj = 0;
		for (kj = 0; kj < m - 1; kj++) { // Проверка индекса столбца
			if (kj == j) { 
				dj = 1; }
			p[ki][kj] = matr[ki + di][kj + dj];
		}
	}
}

/*detmatr - функция для нахождения определителя матрицы.
Формальные параметры:
matr - исходная матрица;
n - размерность матрицы.
Локальные переменные:
d - значение определителя матрицы;
p - матрица для нахождения минора;
k - множитель единицы в степени i+j;
i - счётчик строк;
m - размерность матрицы n-1.
Функция, используемая в программе:
GetMatr - процедура для нахождения минора матрицы.
*/
double detmatr(double **matr, int n) {
	int i, k, m;
	double d;
	double **p;
	
	p = new double*[n];                          // Создание вспомогательной 
	for (i = 0; i < n; i++)                      // динамической матрицы
		p[i] = new double[n];
    
	d = 0;
	k = 1;
	m = n - 1;
	if (n < 1) cout << "Определитель вычислить невозможно!";

	if (n == 1) {                                // Нахождение определителя, если
		d = matr[0][0];                          // размерность матрицы равна 1
		return(d);
	}
	                                             // Нахождение определителя, если
	if (n == 2) {                                // размерность матрицы равна 2
		d = matr[0][0] * matr[1][1] -(matr[1][0] * matr[0][1]);
		return(d);
	}

	if (n > 2) {                                 // Нахождение определителя, если 
		for (i = 0; i < n; i++) {                // размерность матрицы больше 2
			GetMatr(matr, p, i, 0, n);
			d = d + k * matr[i][0] * detmatr(p, m);
			k = -k;
		}
	}

	return(d);
}

/*alg - процедура для нахождения матрицы алгебраических дополнений.
Формальные параметры:
matr - исходная матрица;
n - размерность матрицы;
k - индекс строки элемента строки;
l - индекс столбца элемента строки;
m - матрица алгебраических дополнений;
Локальные переменные:
x - индекс строки передаваемого элемента;
y - индекс столбца передаваемого элемента;
i - счётчик строк;
j - счётчик столбцов;
ii - индекс строки исходной матрицы;
ij - индекс столбца исходной матрицы;
xx - индекс строки матрицы алгебраических элементов;
xy - индекс столбца матрицы алгебраических даполнений.
*/
void alg(double **matr[], int n, int k, int l, double **m[]) {
	int x = 0;
	int y = 0;
	int n1 = n - 1;

	for (int i = 0; i < n; ++i) {
		int ii = i * n;
		int xx = x * n1;
		if (i != k) {
			for (int j = 0; j < n; ++j) {
				int ij = ii + j;
				int xy = xx + y;
				if (j != 1) {
					m[xy] = matr[ij];
					y++;
				}
			}
			x++;
			y = 0;
		}
	}
}


int main() {
	setlocale(LC_ALL, "russian");
	int n;
	cout << "Введите размерность квадратной матрицы (2-6): ";
	cin >> n;
	while ((n < 2) || (n > 6)) {
		cout << "Ошибка. Указана недопустимая размерность." << endl;
		cout << "Повторите ввод: ";
		cin >> n;
	}

	double **matr = new double*[n];            // Создание исходной
	for (int i = 0; i < n; i++) {              // динамической матрицы
		matr[i] = new double[i + 1];
	}

	vvod(matr, n);
	cout << "Исходная матрица:" << endl;
	vivod(matr, n);

	cout << setprecision(2);

	double opred = detmatr(matr, n);
	cout << fixed;

	if (opred != 0) {
		cout << "Определитель матрицы равен " << opred << endl;
		double c;

		double **algdop = new double*[n];     // Создание динамической матрицы
		for (int i = 0; i < n; i++) {         // алгебраических дополнений
			algdop[i] = new double[i + 1];
		}
		double **m = new double*[n - 1];      // Создание вспомогательной
		for (int i = 0; i < n - 1; i++) {     // динамической матрицы
			m[i] = new double[i + 1];
		}

		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {     // Заполнение матрицы
				alg(&matr, n, i, j, &m);      // алгебраических дополнений
				if ((i + j) % 2 == 0) {
					c = 1.0;
				}
				else {
					c = -1.0;
				}
				algdop[i][j] = c * detmatr(m, n - 1);
			}
		}
		
		double **talgdop = new double*[n];    
		for (int i = 0; i < n; i++) {         
			talgdop[i] = new double[i + 1];
		}

		for (int i = 0; i < n; i++) {         // Транспонирование матрицы
			for (int j = 0; j < n; j++) {     // алгебраических дополнений
				talgdop[i][j] = algdop[j][i];
			}
		}

		for (int i = 0; i < n; i++) {                       // Нахождение обратной матрицы
			for (int j = 0; j < n; j++) {
				talgdop[i][j] = talgdop[i][j] / opred;
			}
		}
		
		cout << endl;
		cout << "Обратная матрица: " << endl << endl;
		cout << setprecision(3);
		cout << fixed;
		vivod(talgdop, n);
	}
	else {
		cout << "Матрица не может быть обращена, так как определительравен нулю" << endl;
	}


}